"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/async-validator";
exports.ids = ["vendor-chunks/async-validator"];
exports.modules = {

/***/ "(ssr)/./node_modules/async-validator/dist-web/index.js":
/*!********************************************************!*\
  !*** ./node_modules/async-validator/dist-web/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Schema)\n/* harmony export */ });\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct()) {\n        _construct = Reflect.construct.bind();\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\n/* eslint no-console:0 */ var formatRegExp = /%[sdj%]/g;\nvar warning = function warning() {}; // don't print warning message when in production env or node runtime\nif (typeof process !== \"undefined\" && process.env && \"development\" !== \"production\" && \"undefined\" !== \"undefined\" && 0) {}\nfunction convertFieldsError(errors) {\n    if (!errors || !errors.length) return null;\n    var fields = {};\n    errors.forEach(function(error) {\n        var field = error.field;\n        fields[field] = fields[field] || [];\n        fields[field].push(error);\n    });\n    return fields;\n}\nfunction format(template) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    var i = 0;\n    var len = args.length;\n    if (typeof template === \"function\") {\n        return template.apply(null, args);\n    }\n    if (typeof template === \"string\") {\n        var str = template.replace(formatRegExp, function(x) {\n            if (x === \"%%\") {\n                return \"%\";\n            }\n            if (i >= len) {\n                return x;\n            }\n            switch(x){\n                case \"%s\":\n                    return String(args[i++]);\n                case \"%d\":\n                    return Number(args[i++]);\n                case \"%j\":\n                    try {\n                        return JSON.stringify(args[i++]);\n                    } catch (_) {\n                        return \"[Circular]\";\n                    }\n                    break;\n                default:\n                    return x;\n            }\n        });\n        return str;\n    }\n    return template;\n}\nfunction isNativeStringType(type) {\n    return type === \"string\" || type === \"url\" || type === \"hex\" || type === \"email\" || type === \"date\" || type === \"pattern\";\n}\nfunction isEmptyValue(value, type) {\n    if (value === undefined || value === null) {\n        return true;\n    }\n    if (type === \"array\" && Array.isArray(value) && !value.length) {\n        return true;\n    }\n    if (isNativeStringType(type) && typeof value === \"string\" && !value) {\n        return true;\n    }\n    return false;\n}\nfunction asyncParallelArray(arr, func, callback) {\n    var results = [];\n    var total = 0;\n    var arrLength = arr.length;\n    function count(errors) {\n        results.push.apply(results, errors || []);\n        total++;\n        if (total === arrLength) {\n            callback(results);\n        }\n    }\n    arr.forEach(function(a) {\n        func(a, count);\n    });\n}\nfunction asyncSerialArray(arr, func, callback) {\n    var index = 0;\n    var arrLength = arr.length;\n    function next(errors) {\n        if (errors && errors.length) {\n            callback(errors);\n            return;\n        }\n        var original = index;\n        index = index + 1;\n        if (original < arrLength) {\n            func(arr[original], next);\n        } else {\n            callback([]);\n        }\n    }\n    next([]);\n}\nfunction flattenObjArr(objArr) {\n    var ret = [];\n    Object.keys(objArr).forEach(function(k) {\n        ret.push.apply(ret, objArr[k] || []);\n    });\n    return ret;\n}\nvar AsyncValidationError = /*#__PURE__*/ function(_Error) {\n    _inheritsLoose(AsyncValidationError, _Error);\n    function AsyncValidationError(errors, fields) {\n        var _this;\n        _this = _Error.call(this, \"Async Validation Error\") || this;\n        _this.errors = errors;\n        _this.fields = fields;\n        return _this;\n    }\n    return AsyncValidationError;\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nfunction asyncMap(objArr, option, func, callback, source) {\n    if (option.first) {\n        var _pending = new Promise(function(resolve, reject) {\n            var next = function next(errors) {\n                callback(errors);\n                return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);\n            };\n            var flattenArr = flattenObjArr(objArr);\n            asyncSerialArray(flattenArr, func, next);\n        });\n        _pending[\"catch\"](function(e) {\n            return e;\n        });\n        return _pending;\n    }\n    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];\n    var objArrKeys = Object.keys(objArr);\n    var objArrLength = objArrKeys.length;\n    var total = 0;\n    var results = [];\n    var pending = new Promise(function(resolve, reject) {\n        var next = function next(errors) {\n            results.push.apply(results, errors);\n            total++;\n            if (total === objArrLength) {\n                callback(results);\n                return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);\n            }\n        };\n        if (!objArrKeys.length) {\n            callback(results);\n            resolve(source);\n        }\n        objArrKeys.forEach(function(key) {\n            var arr = objArr[key];\n            if (firstFields.indexOf(key) !== -1) {\n                asyncSerialArray(arr, func, next);\n            } else {\n                asyncParallelArray(arr, func, next);\n            }\n        });\n    });\n    pending[\"catch\"](function(e) {\n        return e;\n    });\n    return pending;\n}\nfunction isErrorObj(obj) {\n    return !!(obj && obj.message !== undefined);\n}\nfunction getValue(value, path) {\n    var v = value;\n    for(var i = 0; i < path.length; i++){\n        if (v == undefined) {\n            return v;\n        }\n        v = v[path[i]];\n    }\n    return v;\n}\nfunction complementError(rule, source) {\n    return function(oe) {\n        var fieldValue;\n        if (rule.fullFields) {\n            fieldValue = getValue(source, rule.fullFields);\n        } else {\n            fieldValue = source[oe.field || rule.fullField];\n        }\n        if (isErrorObj(oe)) {\n            oe.field = oe.field || rule.fullField;\n            oe.fieldValue = fieldValue;\n            return oe;\n        }\n        return {\n            message: typeof oe === \"function\" ? oe() : oe,\n            fieldValue: fieldValue,\n            field: oe.field || rule.fullField\n        };\n    };\n}\nfunction deepMerge(target, source) {\n    if (source) {\n        for(var s in source){\n            if (source.hasOwnProperty(s)) {\n                var value = source[s];\n                if (typeof value === \"object\" && typeof target[s] === \"object\") {\n                    target[s] = _extends({}, target[s], value);\n                } else {\n                    target[s] = value;\n                }\n            }\n        }\n    }\n    return target;\n}\nvar required$1 = function required(rule, value, source, errors, options, type) {\n    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {\n        errors.push(format(options.messages.required, rule.fullField));\n    }\n};\n/**\n *  Rule for validating whitespace.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */ var whitespace = function whitespace(rule, value, source, errors, options) {\n    if (/^\\s+$/.test(value) || value === \"\") {\n        errors.push(format(options.messages.whitespace, rule.fullField));\n    }\n};\n// https://github.com/kevva/url-regex/blob/master/index.js\nvar urlReg;\nvar getUrlRegex = function() {\n    if (urlReg) {\n        return urlReg;\n    }\n    var word = \"[a-fA-F\\\\d:]\";\n    var b = function b(options) {\n        return options && options.includeBoundaries ? \"(?:(?<=\\\\s|^)(?=\" + word + \")|(?<=\" + word + \")(?=\\\\s|$))\" : \"\";\n    };\n    var v4 = \"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\";\n    var v6seg = \"[a-fA-F\\\\d]{1,4}\";\n    var v6 = (\"\\n(?:\\n(?:\" + v6seg + \":){7}(?:\" + v6seg + \"|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\\n(?:\" + v6seg + \":){6}(?:\" + v4 + \"|:\" + v6seg + \"|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\\n(?:\" + v6seg + \":){5}(?::\" + v4 + \"|(?::\" + v6seg + \"){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\\n(?:\" + v6seg + \":){4}(?:(?::\" + v6seg + \"){0,1}:\" + v4 + \"|(?::\" + v6seg + \"){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\\n(?:\" + v6seg + \":){3}(?:(?::\" + v6seg + \"){0,2}:\" + v4 + \"|(?::\" + v6seg + \"){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){2}(?:(?::\" + v6seg + \"){0,3}:\" + v4 + \"|(?::\" + v6seg + \"){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){1}(?:(?::\" + v6seg + \"){0,4}:\" + v4 + \"|(?::\" + v6seg + \"){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\\n(?::(?:(?::\" + v6seg + \"){0,5}:\" + v4 + \"|(?::\" + v6seg + \"){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\\n\").replace(/\\s*\\/\\/.*$/gm, \"\").replace(/\\n/g, \"\").trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful\n    var v46Exact = new RegExp(\"(?:^\" + v4 + \"$)|(?:^\" + v6 + \"$)\");\n    var v4exact = new RegExp(\"^\" + v4 + \"$\");\n    var v6exact = new RegExp(\"^\" + v6 + \"$\");\n    var ip = function ip(options) {\n        return options && options.exact ? v46Exact : new RegExp(\"(?:\" + b(options) + v4 + b(options) + \")|(?:\" + b(options) + v6 + b(options) + \")\", \"g\");\n    };\n    ip.v4 = function(options) {\n        return options && options.exact ? v4exact : new RegExp(\"\" + b(options) + v4 + b(options), \"g\");\n    };\n    ip.v6 = function(options) {\n        return options && options.exact ? v6exact : new RegExp(\"\" + b(options) + v6 + b(options), \"g\");\n    };\n    var protocol = \"(?:(?:[a-z]+:)?//)\";\n    var auth = \"(?:\\\\S+(?::\\\\S*)?@)?\";\n    var ipv4 = ip.v4().source;\n    var ipv6 = ip.v6().source;\n    var host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n    var domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n    var tld = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\";\n    var port = \"(?::\\\\d{2,5})?\";\n    var path = '(?:[/?#][^\\\\s\"]*)?';\n    var regex = \"(?:\" + protocol + \"|www\\\\.)\" + auth + \"(?:localhost|\" + ipv4 + \"|\" + ipv6 + \"|\" + host + domain + tld + \")\" + port + path;\n    urlReg = new RegExp(\"(?:^\" + regex + \"$)\", \"i\");\n    return urlReg;\n};\n/* eslint max-len:0 */ var pattern$2 = {\n    // http://emailregex.com/\n    email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+\\.)+[a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}))$/,\n    // url: new RegExp(\n    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$',\n    //   'i',\n    // ),\n    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i\n};\nvar types = {\n    integer: function integer(value) {\n        return types.number(value) && parseInt(value, 10) === value;\n    },\n    \"float\": function float(value) {\n        return types.number(value) && !types.integer(value);\n    },\n    array: function array(value) {\n        return Array.isArray(value);\n    },\n    regexp: function regexp(value) {\n        if (value instanceof RegExp) {\n            return true;\n        }\n        try {\n            return !!new RegExp(value);\n        } catch (e) {\n            return false;\n        }\n    },\n    date: function date(value) {\n        return typeof value.getTime === \"function\" && typeof value.getMonth === \"function\" && typeof value.getYear === \"function\" && !isNaN(value.getTime());\n    },\n    number: function number(value) {\n        if (isNaN(value)) {\n            return false;\n        }\n        return typeof value === \"number\";\n    },\n    object: function object(value) {\n        return typeof value === \"object\" && !types.array(value);\n    },\n    method: function method(value) {\n        return typeof value === \"function\";\n    },\n    email: function email(value) {\n        return typeof value === \"string\" && value.length <= 320 && !!value.match(pattern$2.email);\n    },\n    url: function url(value) {\n        return typeof value === \"string\" && value.length <= 2048 && !!value.match(getUrlRegex());\n    },\n    hex: function hex(value) {\n        return typeof value === \"string\" && !!value.match(pattern$2.hex);\n    }\n};\nvar type$1 = function type(rule, value, source, errors, options) {\n    if (rule.required && value === undefined) {\n        required$1(rule, value, source, errors, options);\n        return;\n    }\n    var custom = [\n        \"integer\",\n        \"float\",\n        \"array\",\n        \"regexp\",\n        \"object\",\n        \"method\",\n        \"email\",\n        \"number\",\n        \"date\",\n        \"url\",\n        \"hex\"\n    ];\n    var ruleType = rule.type;\n    if (custom.indexOf(ruleType) > -1) {\n        if (!types[ruleType](value)) {\n            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n        } // straight typeof check\n    } else if (ruleType && typeof value !== rule.type) {\n        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n    }\n};\nvar range = function range(rule, value, source, errors, options) {\n    var len = typeof rule.len === \"number\";\n    var min = typeof rule.min === \"number\";\n    var max = typeof rule.max === \"number\"; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）\n    var spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    var val = value;\n    var key = null;\n    var num = typeof value === \"number\";\n    var str = typeof value === \"string\";\n    var arr = Array.isArray(value);\n    if (num) {\n        key = \"number\";\n    } else if (str) {\n        key = \"string\";\n    } else if (arr) {\n        key = \"array\";\n    } // if the value is not of a supported type for range validation\n    // the validation rule rule should use the\n    // type property to also test for a particular type\n    if (!key) {\n        return false;\n    }\n    if (arr) {\n        val = value.length;\n    }\n    if (str) {\n        // 处理码点大于U+010000的文字length属性不准确的bug，如\"𠮷𠮷𠮷\".lenght !== 3\n        val = value.replace(spRegexp, \"_\").length;\n    }\n    if (len) {\n        if (val !== rule.len) {\n            errors.push(format(options.messages[key].len, rule.fullField, rule.len));\n        }\n    } else if (min && !max && val < rule.min) {\n        errors.push(format(options.messages[key].min, rule.fullField, rule.min));\n    } else if (max && !min && val > rule.max) {\n        errors.push(format(options.messages[key].max, rule.fullField, rule.max));\n    } else if (min && max && (val < rule.min || val > rule.max)) {\n        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));\n    }\n};\nvar ENUM$1 = \"enum\";\nvar enumerable$1 = function enumerable(rule, value, source, errors, options) {\n    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];\n    if (rule[ENUM$1].indexOf(value) === -1) {\n        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(\", \")));\n    }\n};\nvar pattern$1 = function pattern(rule, value, source, errors, options) {\n    if (rule.pattern) {\n        if (rule.pattern instanceof RegExp) {\n            // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n            // flag is accidentally set to `true`, which in a validation scenario\n            // is not necessary and the result might be misleading\n            rule.pattern.lastIndex = 0;\n            if (!rule.pattern.test(value)) {\n                errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n            }\n        } else if (typeof rule.pattern === \"string\") {\n            var _pattern = new RegExp(rule.pattern);\n            if (!_pattern.test(value)) {\n                errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n            }\n        }\n    }\n};\nvar rules = {\n    required: required$1,\n    whitespace: whitespace,\n    type: type$1,\n    range: range,\n    \"enum\": enumerable$1,\n    pattern: pattern$1\n};\nvar string = function string(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, \"string\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, \"string\");\n        if (!isEmptyValue(value, \"string\")) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n            rules.pattern(rule, value, source, errors, options);\n            if (rule.whitespace === true) {\n                rules.whitespace(rule, value, source, errors, options);\n            }\n        }\n    }\n    callback(errors);\n};\nvar method = function method(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar number = function number(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (value === \"\") {\n            value = undefined;\n        }\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar _boolean = function _boolean(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar regexp = function regexp(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value)) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar integer = function integer(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar floatFn = function floatFn(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar array = function array(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if ((value === undefined || value === null) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, \"array\");\n        if (value !== undefined && value !== null) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar object = function object(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar ENUM = \"enum\";\nvar enumerable = function enumerable(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules[ENUM](rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar pattern = function pattern(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, \"string\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value, \"string\")) {\n            rules.pattern(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar date = function date(rule, value, callback, source, options) {\n    // console.log('integer rule called %j', rule);\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);\n    if (validate) {\n        if (isEmptyValue(value, \"date\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value, \"date\")) {\n            var dateObject;\n            if (value instanceof Date) {\n                dateObject = value;\n            } else {\n                dateObject = new Date(value);\n            }\n            rules.type(rule, dateObject, source, errors, options);\n            if (dateObject) {\n                rules.range(rule, dateObject.getTime(), source, errors, options);\n            }\n        }\n    }\n    callback(errors);\n};\nvar required = function required(rule, value, callback, source, options) {\n    var errors = [];\n    var type = Array.isArray(value) ? \"array\" : typeof value;\n    rules.required(rule, value, source, errors, options, type);\n    callback(errors);\n};\nvar type = function type(rule, value, callback, source, options) {\n    var ruleType = rule.type;\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, ruleType) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, ruleType);\n        if (!isEmptyValue(value, ruleType)) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar any = function any(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n    }\n    callback(errors);\n};\nvar validators = {\n    string: string,\n    method: method,\n    number: number,\n    \"boolean\": _boolean,\n    regexp: regexp,\n    integer: integer,\n    \"float\": floatFn,\n    array: array,\n    object: object,\n    \"enum\": enumerable,\n    pattern: pattern,\n    date: date,\n    url: type,\n    hex: type,\n    email: type,\n    required: required,\n    any: any\n};\nfunction newMessages() {\n    return {\n        \"default\": \"Validation error on field %s\",\n        required: \"%s is required\",\n        \"enum\": \"%s must be one of %s\",\n        whitespace: \"%s cannot be empty\",\n        date: {\n            format: \"%s date %s is invalid for format %s\",\n            parse: \"%s date could not be parsed, %s is invalid \",\n            invalid: \"%s date %s is invalid\"\n        },\n        types: {\n            string: \"%s is not a %s\",\n            method: \"%s is not a %s (function)\",\n            array: \"%s is not an %s\",\n            object: \"%s is not an %s\",\n            number: \"%s is not a %s\",\n            date: \"%s is not a %s\",\n            \"boolean\": \"%s is not a %s\",\n            integer: \"%s is not an %s\",\n            \"float\": \"%s is not a %s\",\n            regexp: \"%s is not a valid %s\",\n            email: \"%s is not a valid %s\",\n            url: \"%s is not a valid %s\",\n            hex: \"%s is not a valid %s\"\n        },\n        string: {\n            len: \"%s must be exactly %s characters\",\n            min: \"%s must be at least %s characters\",\n            max: \"%s cannot be longer than %s characters\",\n            range: \"%s must be between %s and %s characters\"\n        },\n        number: {\n            len: \"%s must equal %s\",\n            min: \"%s cannot be less than %s\",\n            max: \"%s cannot be greater than %s\",\n            range: \"%s must be between %s and %s\"\n        },\n        array: {\n            len: \"%s must be exactly %s in length\",\n            min: \"%s cannot be less than %s in length\",\n            max: \"%s cannot be greater than %s in length\",\n            range: \"%s must be between %s and %s in length\"\n        },\n        pattern: {\n            mismatch: \"%s value %s does not match pattern %s\"\n        },\n        clone: function clone() {\n            var cloned = JSON.parse(JSON.stringify(this));\n            cloned.clone = this.clone;\n            return cloned;\n        }\n    };\n}\nvar messages = newMessages();\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */ var Schema = /*#__PURE__*/ function() {\n    // ========================= Static =========================\n    // ======================== Instance ========================\n    function Schema(descriptor) {\n        this.rules = null;\n        this._messages = messages;\n        this.define(descriptor);\n    }\n    var _proto = Schema.prototype;\n    _proto.define = function define(rules) {\n        var _this = this;\n        if (!rules) {\n            throw new Error(\"Cannot configure a schema with no rules\");\n        }\n        if (typeof rules !== \"object\" || Array.isArray(rules)) {\n            throw new Error(\"Rules must be an object\");\n        }\n        this.rules = {};\n        Object.keys(rules).forEach(function(name) {\n            var item = rules[name];\n            _this.rules[name] = Array.isArray(item) ? item : [\n                item\n            ];\n        });\n    };\n    _proto.messages = function messages(_messages) {\n        if (_messages) {\n            this._messages = deepMerge(newMessages(), _messages);\n        }\n        return this._messages;\n    };\n    _proto.validate = function validate(source_, o, oc) {\n        var _this2 = this;\n        if (o === void 0) {\n            o = {};\n        }\n        if (oc === void 0) {\n            oc = function oc() {};\n        }\n        var source = source_;\n        var options = o;\n        var callback = oc;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!this.rules || Object.keys(this.rules).length === 0) {\n            if (callback) {\n                callback(null, source);\n            }\n            return Promise.resolve(source);\n        }\n        function complete(results) {\n            var errors = [];\n            var fields = {};\n            function add(e) {\n                if (Array.isArray(e)) {\n                    var _errors;\n                    errors = (_errors = errors).concat.apply(_errors, e);\n                } else {\n                    errors.push(e);\n                }\n            }\n            for(var i = 0; i < results.length; i++){\n                add(results[i]);\n            }\n            if (!errors.length) {\n                callback(null, source);\n            } else {\n                fields = convertFieldsError(errors);\n                callback(errors, fields);\n            }\n        }\n        if (options.messages) {\n            var messages$1 = this.messages();\n            if (messages$1 === messages) {\n                messages$1 = newMessages();\n            }\n            deepMerge(messages$1, options.messages);\n            options.messages = messages$1;\n        } else {\n            options.messages = this.messages();\n        }\n        var series = {};\n        var keys = options.keys || Object.keys(this.rules);\n        keys.forEach(function(z) {\n            var arr = _this2.rules[z];\n            var value = source[z];\n            arr.forEach(function(r) {\n                var rule = r;\n                if (typeof rule.transform === \"function\") {\n                    if (source === source_) {\n                        source = _extends({}, source);\n                    }\n                    value = source[z] = rule.transform(value);\n                }\n                if (typeof rule === \"function\") {\n                    rule = {\n                        validator: rule\n                    };\n                } else {\n                    rule = _extends({}, rule);\n                } // Fill validator. Skip if nothing need to validate\n                rule.validator = _this2.getValidationMethod(rule);\n                if (!rule.validator) {\n                    return;\n                }\n                rule.field = z;\n                rule.fullField = rule.fullField || z;\n                rule.type = _this2.getType(rule);\n                series[z] = series[z] || [];\n                series[z].push({\n                    rule: rule,\n                    value: value,\n                    source: source,\n                    field: z\n                });\n            });\n        });\n        var errorFields = {};\n        return asyncMap(series, options, function(data, doIt) {\n            var rule = data.rule;\n            var deep = (rule.type === \"object\" || rule.type === \"array\") && (typeof rule.fields === \"object\" || typeof rule.defaultField === \"object\");\n            deep = deep && (rule.required || !rule.required && data.value);\n            rule.field = data.field;\n            function addFullField(key, schema) {\n                return _extends({}, schema, {\n                    fullField: rule.fullField + \".\" + key,\n                    fullFields: rule.fullFields ? [].concat(rule.fullFields, [\n                        key\n                    ]) : [\n                        key\n                    ]\n                });\n            }\n            function cb(e) {\n                if (e === void 0) {\n                    e = [];\n                }\n                var errorList = Array.isArray(e) ? e : [\n                    e\n                ];\n                if (!options.suppressWarning && errorList.length) {\n                    Schema.warning(\"async-validator:\", errorList);\n                }\n                if (errorList.length && rule.message !== undefined) {\n                    errorList = [].concat(rule.message);\n                } // Fill error info\n                var filledErrors = errorList.map(complementError(rule, source));\n                if (options.first && filledErrors.length) {\n                    errorFields[rule.field] = 1;\n                    return doIt(filledErrors);\n                }\n                if (!deep) {\n                    doIt(filledErrors);\n                } else {\n                    // if rule is required but the target object\n                    // does not exist fail at the rule level and don't\n                    // go deeper\n                    if (rule.required && !data.value) {\n                        if (rule.message !== undefined) {\n                            filledErrors = [].concat(rule.message).map(complementError(rule, source));\n                        } else if (options.error) {\n                            filledErrors = [\n                                options.error(rule, format(options.messages.required, rule.field))\n                            ];\n                        }\n                        return doIt(filledErrors);\n                    }\n                    var fieldsSchema = {};\n                    if (rule.defaultField) {\n                        Object.keys(data.value).map(function(key) {\n                            fieldsSchema[key] = rule.defaultField;\n                        });\n                    }\n                    fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);\n                    var paredFieldsSchema = {};\n                    Object.keys(fieldsSchema).forEach(function(field) {\n                        var fieldSchema = fieldsSchema[field];\n                        var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [\n                            fieldSchema\n                        ];\n                        paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));\n                    });\n                    var schema = new Schema(paredFieldsSchema);\n                    schema.messages(options.messages);\n                    if (data.rule.options) {\n                        data.rule.options.messages = options.messages;\n                        data.rule.options.error = options.error;\n                    }\n                    schema.validate(data.value, data.rule.options || options, function(errs) {\n                        var finalErrors = [];\n                        if (filledErrors && filledErrors.length) {\n                            finalErrors.push.apply(finalErrors, filledErrors);\n                        }\n                        if (errs && errs.length) {\n                            finalErrors.push.apply(finalErrors, errs);\n                        }\n                        doIt(finalErrors.length ? finalErrors : null);\n                    });\n                }\n            }\n            var res;\n            if (rule.asyncValidator) {\n                res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n            } else if (rule.validator) {\n                try {\n                    res = rule.validator(rule, data.value, cb, data.source, options);\n                } catch (error) {\n                    console.error == null ? void 0 : console.error(error); // rethrow to report error\n                    if (!options.suppressValidatorError) {\n                        setTimeout(function() {\n                            throw error;\n                        }, 0);\n                    }\n                    cb(error.message);\n                }\n                if (res === true) {\n                    cb();\n                } else if (res === false) {\n                    cb(typeof rule.message === \"function\" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + \" fails\");\n                } else if (res instanceof Array) {\n                    cb(res);\n                } else if (res instanceof Error) {\n                    cb(res.message);\n                }\n            }\n            if (res && res.then) {\n                res.then(function() {\n                    return cb();\n                }, function(e) {\n                    return cb(e);\n                });\n            }\n        }, function(results) {\n            complete(results);\n        }, source);\n    };\n    _proto.getType = function getType(rule) {\n        if (rule.type === undefined && rule.pattern instanceof RegExp) {\n            rule.type = \"pattern\";\n        }\n        if (typeof rule.validator !== \"function\" && rule.type && !validators.hasOwnProperty(rule.type)) {\n            throw new Error(format(\"Unknown rule type %s\", rule.type));\n        }\n        return rule.type || \"string\";\n    };\n    _proto.getValidationMethod = function getValidationMethod(rule) {\n        if (typeof rule.validator === \"function\") {\n            return rule.validator;\n        }\n        var keys = Object.keys(rule);\n        var messageIndex = keys.indexOf(\"message\");\n        if (messageIndex !== -1) {\n            keys.splice(messageIndex, 1);\n        }\n        if (keys.length === 1 && keys[0] === \"required\") {\n            return validators.required;\n        }\n        return validators[this.getType(rule)] || undefined;\n    };\n    return Schema;\n}();\nSchema.register = function register(type, validator) {\n    if (typeof validator !== \"function\") {\n        throw new Error(\"Cannot register a validator by type, validator is not a function\");\n    }\n    validators[type] = validator;\n};\nSchema.warning = warning;\nSchema.messages = messages;\nSchema.validators = validators;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXN5bmMtdmFsaWRhdG9yL2Rpc3Qtd2ViL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFFekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBRUEsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsU0FBU1EsZUFBZUMsUUFBUSxFQUFFQyxVQUFVO0lBQzFDRCxTQUFTTCxTQUFTLEdBQUdULE9BQU9nQixNQUFNLENBQUNELFdBQVdOLFNBQVM7SUFDdkRLLFNBQVNMLFNBQVMsQ0FBQ1EsV0FBVyxHQUFHSDtJQUVqQ0ksZ0JBQWdCSixVQUFVQztBQUM1QjtBQUVBLFNBQVNJLGdCQUFnQkMsQ0FBQztJQUN4QkQsa0JBQWtCbkIsT0FBT3FCLGNBQWMsR0FBR3JCLE9BQU9zQixjQUFjLENBQUNwQixJQUFJLEtBQUssU0FBU2lCLGdCQUFnQkMsQ0FBQztRQUNqRyxPQUFPQSxFQUFFRyxTQUFTLElBQUl2QixPQUFPc0IsY0FBYyxDQUFDRjtJQUM5QztJQUNBLE9BQU9ELGdCQUFnQkM7QUFDekI7QUFFQSxTQUFTRixnQkFBZ0JFLENBQUMsRUFBRUksQ0FBQztJQUMzQk4sa0JBQWtCbEIsT0FBT3FCLGNBQWMsR0FBR3JCLE9BQU9xQixjQUFjLENBQUNuQixJ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LE9BQU9vRSxLQUFLcEUsSUFBSSxJQUFJO0lBQ3RCO0lBRUFnSyxPQUFPZ0IsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQW9CNUcsSUFBSTtRQUM1RCxJQUFJLE9BQU9BLEtBQUsyRyxTQUFTLEtBQUssWUFBWTtZQUN4QyxPQUFPM0csS0FBSzJHLFNBQVM7UUFDdkI7UUFFQSxJQUFJcEksT0FBTzNHLE9BQU8yRyxJQUFJLENBQUN5QjtRQUN2QixJQUFJcUksZUFBZTlKLEtBQUs5RCxPQUFPLENBQUM7UUFFaEMsSUFBSTROLGlCQUFpQixDQUFDLEdBQUc7WUFDdkI5SixLQUFLK0osTUFBTSxDQUFDRCxjQUFjO1FBQzVCO1FBRUEsSUFBSTlKLEtBQUtyRyxNQUFNLEtBQUssS0FBS3FHLElBQUksQ0FBQyxFQUFFLEtBQUssWUFBWTtZQUMvQyxPQUFPMkcsV0FBVzFFLFFBQVE7UUFDNUI7UUFFQSxPQUFPMEUsVUFBVSxDQUFDLElBQUksQ0FBQzJCLE9BQU8sQ0FBQzdHLE1BQU0sSUFBSW5GO0lBQzNDO0lBRUEsT0FBTzJLO0FBQ1Q7QUFFQUEsT0FBTytDLFFBQVEsR0FBRyxTQUFTQSxTQUFTM00sSUFBSSxFQUFFK0ssU0FBUztJQUNqRCxJQUFJLE9BQU9BLGNBQWMsWUFBWTtRQUNuQyxNQUFNLElBQUkvSCxNQUFNO0lBQ2xCO0lBRUFzRyxVQUFVLENBQUN0SixLQUFLLEdBQUcrSztBQUNyQjtBQUVBbkIsT0FBT2hLLE9BQU8sR0FBR0E7QUFDakJnSyxPQUFPOUUsUUFBUSxHQUFHQTtBQUNsQjhFLE9BQU9OLFVBQVUsR0FBR0E7QUFFUyxDQUM3QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNoZXNzLy4vbm9kZV9tb2R1bGVzL2FzeW5jLXZhbGlkYXRvci9kaXN0LXdlYi9pbmRleC5qcz9mZTNkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuXG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxuLyogZXNsaW50IG5vLWNvbnNvbGU6MCAqL1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG52YXIgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoKSB7fTsgLy8gZG9uJ3QgcHJpbnQgd2FybmluZyBtZXNzYWdlIHdoZW4gaW4gcHJvZHVjdGlvbiBlbnYgb3Igbm9kZSBydW50aW1lXG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKHR5cGUsIGVycm9ycykge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuICYmIHR5cGVvZiBBU1lOQ19WQUxJREFUT1JfTk9fV0FSTklORyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChlcnJvcnMuZXZlcnkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlID09PSAnc3RyaW5nJztcbiAgICAgIH0pKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih0eXBlLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZpZWxkc0Vycm9yKGVycm9ycykge1xuICBpZiAoIWVycm9ycyB8fCAhZXJyb3JzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdmFyIGZpZWxkID0gZXJyb3IuZmllbGQ7XG4gICAgZmllbGRzW2ZpZWxkXSA9IGZpZWxkc1tmaWVsZF0gfHwgW107XG4gICAgZmllbGRzW2ZpZWxkXS5wdXNoKGVycm9yKTtcbiAgfSk7XG4gIHJldHVybiBmaWVsZHM7XG59XG5mdW5jdGlvbiBmb3JtYXQodGVtcGxhdGUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5hcHBseShudWxsLCBhcmdzKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHN0ciA9IHRlbXBsYXRlLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHggPT09ICclJScpIHtcbiAgICAgICAgcmV0dXJuICclJztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgY2FzZSAnJXMnOlxuICAgICAgICAgIHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcblxuICAgICAgICBjYXNlICclZCc6XG4gICAgICAgICAgcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuXG4gICAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbmZ1bmN0aW9uIGlzTmF0aXZlU3RyaW5nVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAndXJsJyB8fCB0eXBlID09PSAnaGV4JyB8fCB0eXBlID09PSAnZW1haWwnIHx8IHR5cGUgPT09ICdkYXRlJyB8fCB0eXBlID09PSAncGF0dGVybic7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdhcnJheScgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIXZhbHVlLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzTmF0aXZlU3RyaW5nVHlwZSh0eXBlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICF2YWx1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhc3luY1BhcmFsbGVsQXJyYXkoYXJyLCBmdW5jLCBjYWxsYmFjaykge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgdG90YWwgPSAwO1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmdW5jdGlvbiBjb3VudChlcnJvcnMpIHtcbiAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgZXJyb3JzIHx8IFtdKTtcbiAgICB0b3RhbCsrO1xuXG4gICAgaWYgKHRvdGFsID09PSBhcnJMZW5ndGgpIHtcbiAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xuICAgIH1cbiAgfVxuXG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgZnVuYyhhLCBjb3VudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3luY1NlcmlhbEFycmF5KGFyciwgZnVuYywgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gbmV4dChlcnJvcnMpIHtcbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9ycyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG4gICAgaW5kZXggPSBpbmRleCArIDE7XG5cbiAgICBpZiAob3JpZ2luYWwgPCBhcnJMZW5ndGgpIHtcbiAgICAgIGZ1bmMoYXJyW29yaWdpbmFsXSwgbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKFtdKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KFtdKTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbk9iakFycihvYmpBcnIpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBPYmplY3Qua2V5cyhvYmpBcnIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICByZXQucHVzaC5hcHBseShyZXQsIG9iakFycltrXSB8fCBbXSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG52YXIgQXN5bmNWYWxpZGF0aW9uRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShBc3luY1ZhbGlkYXRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3luY1ZhbGlkYXRpb25FcnJvcihlcnJvcnMsIGZpZWxkcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Vycm9yLmNhbGwodGhpcywgJ0FzeW5jIFZhbGlkYXRpb24gRXJyb3InKSB8fCB0aGlzO1xuICAgIF90aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICBfdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEFzeW5jVmFsaWRhdGlvbkVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmZ1bmN0aW9uIGFzeW5jTWFwKG9iakFyciwgb3B0aW9uLCBmdW5jLCBjYWxsYmFjaywgc291cmNlKSB7XG4gIGlmIChvcHRpb24uZmlyc3QpIHtcbiAgICB2YXIgX3BlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZXJyb3JzKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycyk7XG4gICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gcmVqZWN0KG5ldyBBc3luY1ZhbGlkYXRpb25FcnJvcihlcnJvcnMsIGNvbnZlcnRGaWVsZHNFcnJvcihlcnJvcnMpKSkgOiByZXNvbHZlKHNvdXJjZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmxhdHRlbkFyciA9IGZsYXR0ZW5PYmpBcnIob2JqQXJyKTtcbiAgICAgIGFzeW5jU2VyaWFsQXJyYXkoZmxhdHRlbkFyciwgZnVuYywgbmV4dCk7XG4gICAgfSk7XG5cbiAgICBfcGVuZGluZ1tcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfcGVuZGluZztcbiAgfVxuXG4gIHZhciBmaXJzdEZpZWxkcyA9IG9wdGlvbi5maXJzdEZpZWxkcyA9PT0gdHJ1ZSA/IE9iamVjdC5rZXlzKG9iakFycikgOiBvcHRpb24uZmlyc3RGaWVsZHMgfHwgW107XG4gIHZhciBvYmpBcnJLZXlzID0gT2JqZWN0LmtleXMob2JqQXJyKTtcbiAgdmFyIG9iakFyckxlbmd0aCA9IG9iakFycktleXMubGVuZ3RoO1xuICB2YXIgdG90YWwgPSAwO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZXJyb3JzKSB7XG4gICAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgZXJyb3JzKTtcbiAgICAgIHRvdGFsKys7XG5cbiAgICAgIGlmICh0b3RhbCA9PT0gb2JqQXJyTGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5sZW5ndGggPyByZWplY3QobmV3IEFzeW5jVmFsaWRhdGlvbkVycm9yKHJlc3VsdHMsIGNvbnZlcnRGaWVsZHNFcnJvcihyZXN1bHRzKSkpIDogcmVzb2x2ZShzb3VyY2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIW9iakFycktleXMubGVuZ3RoKSB7XG4gICAgICBjYWxsYmFjayhyZXN1bHRzKTtcbiAgICAgIHJlc29sdmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBvYmpBcnJLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGFyciA9IG9iakFycltrZXldO1xuXG4gICAgICBpZiAoZmlyc3RGaWVsZHMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICBhc3luY1NlcmlhbEFycmF5KGFyciwgZnVuYywgbmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3luY1BhcmFsbGVsQXJyYXkoYXJyLCBmdW5jLCBuZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHBlbmRpbmdbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgcmV0dXJuIHBlbmRpbmc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JPYmoob2JqKSB7XG4gIHJldHVybiAhIShvYmogJiYgb2JqLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlLCBwYXRoKSB7XG4gIHZhciB2ID0gdmFsdWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHYgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICB2ID0gdltwYXRoW2ldXTtcbiAgfVxuXG4gIHJldHVybiB2O1xufVxuXG5mdW5jdGlvbiBjb21wbGVtZW50RXJyb3IocnVsZSwgc291cmNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAob2UpIHtcbiAgICB2YXIgZmllbGRWYWx1ZTtcblxuICAgIGlmIChydWxlLmZ1bGxGaWVsZHMpIHtcbiAgICAgIGZpZWxkVmFsdWUgPSBnZXRWYWx1ZShzb3VyY2UsIHJ1bGUuZnVsbEZpZWxkcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkVmFsdWUgPSBzb3VyY2Vbb2UuZmllbGQgfHwgcnVsZS5mdWxsRmllbGRdO1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yT2JqKG9lKSkge1xuICAgICAgb2UuZmllbGQgPSBvZS5maWVsZCB8fCBydWxlLmZ1bGxGaWVsZDtcbiAgICAgIG9lLmZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlO1xuICAgICAgcmV0dXJuIG9lO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiB0eXBlb2Ygb2UgPT09ICdmdW5jdGlvbicgPyBvZSgpIDogb2UsXG4gICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlLFxuICAgICAgZmllbGQ6IG9lLmZpZWxkIHx8IHJ1bGUuZnVsbEZpZWxkXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoc291cmNlKSB7XG4gICAgZm9yICh2YXIgcyBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocykpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3NdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXRbc10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGFyZ2V0W3NdID0gX2V4dGVuZHMoe30sIHRhcmdldFtzXSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtzXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIHJlcXVpcmVkJDEgPSBmdW5jdGlvbiByZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsIHR5cGUpIHtcbiAgaWYgKHJ1bGUucmVxdWlyZWQgJiYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCkgfHwgaXNFbXB0eVZhbHVlKHZhbHVlLCB0eXBlIHx8IHJ1bGUudHlwZSkpKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMucmVxdWlyZWQsIHJ1bGUuZnVsbEZpZWxkKSk7XG4gIH1cbn07XG5cbi8qKlxuICogIFJ1bGUgZm9yIHZhbGlkYXRpbmcgd2hpdGVzcGFjZS5cbiAqXG4gKiAgQHBhcmFtIHJ1bGUgVGhlIHZhbGlkYXRpb24gcnVsZS5cbiAqICBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBvbiB0aGUgc291cmNlIG9iamVjdC5cbiAqICBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IGJlaW5nIHZhbGlkYXRlZC5cbiAqICBAcGFyYW0gZXJyb3JzIEFuIGFycmF5IG9mIGVycm9ycyB0aGF0IHRoaXMgcnVsZSBtYXkgYWRkXG4gKiAgdmFsaWRhdGlvbiBlcnJvcnMgdG8uXG4gKiAgQHBhcmFtIG9wdGlvbnMgVGhlIHZhbGlkYXRpb24gb3B0aW9ucy5cbiAqICBAcGFyYW0gb3B0aW9ucy5tZXNzYWdlcyBUaGUgdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqL1xuXG52YXIgd2hpdGVzcGFjZSA9IGZ1bmN0aW9uIHdoaXRlc3BhY2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKSB7XG4gIGlmICgvXlxccyskLy50ZXN0KHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlcy53aGl0ZXNwYWNlLCBydWxlLmZ1bGxGaWVsZCkpO1xuICB9XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V2dmEvdXJsLXJlZ2V4L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG52YXIgdXJsUmVnO1xudmFyIGdldFVybFJlZ2V4ID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHVybFJlZykge1xuICAgIHJldHVybiB1cmxSZWc7XG4gIH1cblxuICB2YXIgd29yZCA9ICdbYS1mQS1GXFxcXGQ6XSc7XG5cbiAgdmFyIGIgPSBmdW5jdGlvbiBiKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVCb3VuZGFyaWVzID8gXCIoPzooPzw9XFxcXHN8XikoPz1cIiArIHdvcmQgKyBcIil8KD88PVwiICsgd29yZCArIFwiKSg/PVxcXFxzfCQpKVwiIDogJyc7XG4gIH07XG5cbiAgdmFyIHY0ID0gJyg/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9JztcbiAgdmFyIHY2c2VnID0gJ1thLWZBLUZcXFxcZF17MSw0fSc7XG4gIHZhciB2NiA9IChcIlxcbig/Olxcbig/OlwiICsgdjZzZWcgKyBcIjopezd9KD86XCIgKyB2NnNlZyArIFwifDopfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE6MjozOjQ6NTo2Ojc6OiAgMToyOjM6NDo1OjY6Nzo4XFxuKD86XCIgKyB2NnNlZyArIFwiOil7Nn0oPzpcIiArIHY0ICsgXCJ8OlwiICsgdjZzZWcgKyBcInw6KXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE6MjozOjQ6NTo2OjogICAgMToyOjM6NDo1OjY6OjggICAxOjI6Mzo0OjU6Njo6OCAgMToyOjM6NDo1OjY6OjEuMi4zLjRcXG4oPzpcIiArIHY2c2VnICsgXCI6KXs1fSg/OjpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSwyfXw6KXwgICAgICAgICAgICAgICAgICAgLy8gMToyOjM6NDo1OjogICAgICAxOjI6Mzo0OjU6Ojc6OCAgIDE6MjozOjQ6NTo6OCAgICAxOjI6Mzo0OjU6Ojc6MS4yLjMuNFxcbig/OlwiICsgdjZzZWcgKyBcIjopezR9KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCwxfTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSwzfXw6KXwgLy8gMToyOjM6NDo6ICAgICAgICAxOjI6Mzo0Ojo2Ojc6OCAgIDE6MjozOjQ6OjggICAgICAxOjI6Mzo0Ojo2Ojc6MS4yLjMuNFxcbig/OlwiICsgdjZzZWcgKyBcIjopezN9KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCwyfTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSw0fXw6KXwgLy8gMToyOjM6OiAgICAgICAgICAxOjI6Mzo6NTo2Ojc6OCAgIDE6MjozOjo4ICAgICAgICAxOjI6Mzo6NTo2Ojc6MS4yLjMuNFxcbig/OlwiICsgdjZzZWcgKyBcIjopezJ9KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCwzfTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSw1fXw6KXwgLy8gMToyOjogICAgICAgICAgICAxOjI6OjQ6NTo2Ojc6OCAgIDE6Mjo6OCAgICAgICAgICAxOjI6OjQ6NTo2Ojc6MS4yLjMuNFxcbig/OlwiICsgdjZzZWcgKyBcIjopezF9KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCw0fTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSw2fXw6KXwgLy8gMTo6ICAgICAgICAgICAgICAxOjozOjQ6NTo2Ojc6OCAgIDE6OjggICAgICAgICAgICAxOjozOjQ6NTo2Ojc6MS4yLjMuNFxcbig/OjooPzooPzo6XCIgKyB2NnNlZyArIFwiKXswLDV9OlwiICsgdjQgKyBcInwoPzo6XCIgKyB2NnNlZyArIFwiKXsxLDd9fDopKSAgICAgICAgICAgICAvLyA6OjI6Mzo0OjU6Njo3OjggIDo6MjozOjQ6NTo2Ojc6OCAgOjo4ICAgICAgICAgICAgIDo6MS4yLjMuNFxcbikoPzolWzAtOWEtekEtWl17MSx9KT8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAlZXRoMCAgICAgICAgICAgICUxXFxuXCIpLnJlcGxhY2UoL1xccypcXC9cXC8uKiQvZ20sICcnKS5yZXBsYWNlKC9cXG4vZywgJycpLnRyaW0oKTsgLy8gUHJlLWNvbXBpbGUgb25seSB0aGUgZXhhY3QgcmVnZXhlcyBiZWNhdXNlIGFkZGluZyBhIGdsb2JhbCBmbGFnIG1ha2UgcmVnZXhlcyBzdGF0ZWZ1bFxuXG4gIHZhciB2NDZFeGFjdCA9IG5ldyBSZWdFeHAoXCIoPzpeXCIgKyB2NCArIFwiJCl8KD86XlwiICsgdjYgKyBcIiQpXCIpO1xuICB2YXIgdjRleGFjdCA9IG5ldyBSZWdFeHAoXCJeXCIgKyB2NCArIFwiJFwiKTtcbiAgdmFyIHY2ZXhhY3QgPSBuZXcgUmVnRXhwKFwiXlwiICsgdjYgKyBcIiRcIik7XG5cbiAgdmFyIGlwID0gZnVuY3Rpb24gaXAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuZXhhY3QgPyB2NDZFeGFjdCA6IG5ldyBSZWdFeHAoXCIoPzpcIiArIGIob3B0aW9ucykgKyB2NCArIGIob3B0aW9ucykgKyBcIil8KD86XCIgKyBiKG9wdGlvbnMpICsgdjYgKyBiKG9wdGlvbnMpICsgXCIpXCIsICdnJyk7XG4gIH07XG5cbiAgaXAudjQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuZXhhY3QgPyB2NGV4YWN0IDogbmV3IFJlZ0V4cChcIlwiICsgYihvcHRpb25zKSArIHY0ICsgYihvcHRpb25zKSwgJ2cnKTtcbiAgfTtcblxuICBpcC52NiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5leGFjdCA/IHY2ZXhhY3QgOiBuZXcgUmVnRXhwKFwiXCIgKyBiKG9wdGlvbnMpICsgdjYgKyBiKG9wdGlvbnMpLCAnZycpO1xuICB9O1xuXG4gIHZhciBwcm90b2NvbCA9IFwiKD86KD86W2Etel0rOik/Ly8pXCI7XG4gIHZhciBhdXRoID0gJyg/OlxcXFxTKyg/OjpcXFxcUyopP0ApPyc7XG4gIHZhciBpcHY0ID0gaXAudjQoKS5zb3VyY2U7XG4gIHZhciBpcHY2ID0gaXAudjYoKS5zb3VyY2U7XG4gIHZhciBob3N0ID0gXCIoPzooPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV1bLV9dKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKylcIjtcbiAgdmFyIGRvbWFpbiA9IFwiKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykqXCI7XG4gIHZhciB0bGQgPSBcIig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpXCI7XG4gIHZhciBwb3J0ID0gJyg/OjpcXFxcZHsyLDV9KT8nO1xuICB2YXIgcGF0aCA9ICcoPzpbLz8jXVteXFxcXHNcIl0qKT8nO1xuICB2YXIgcmVnZXggPSBcIig/OlwiICsgcHJvdG9jb2wgKyBcInx3d3dcXFxcLilcIiArIGF1dGggKyBcIig/OmxvY2FsaG9zdHxcIiArIGlwdjQgKyBcInxcIiArIGlwdjYgKyBcInxcIiArIGhvc3QgKyBkb21haW4gKyB0bGQgKyBcIilcIiArIHBvcnQgKyBwYXRoO1xuICB1cmxSZWcgPSBuZXcgUmVnRXhwKFwiKD86XlwiICsgcmVnZXggKyBcIiQpXCIsICdpJyk7XG4gIHJldHVybiB1cmxSZWc7XG59KTtcblxuLyogZXNsaW50IG1heC1sZW46MCAqL1xuXG52YXIgcGF0dGVybiQyID0ge1xuICAvLyBodHRwOi8vZW1haWxyZWdleC5jb20vXG4gIGVtYWlsOiAvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31dKXwoKFthLXpBLVpcXC0wLTlcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1xcLikrW2EtekEtWlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl17Mix9KSkkLyxcbiAgLy8gdXJsOiBuZXcgUmVnRXhwKFxuICAvLyAgICdeKD8hbWFpbHRvOikoPzooPzpodHRwfGh0dHBzfGZ0cCk6Ly98Ly8pKD86XFxcXFMrKD86OlxcXFxTKik/QCk/KD86KD86KD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswMV1cXFxcZHwyMlswLTNdKSg/OlxcXFwuKD86MT9cXFxcZHsxLDJ9fDJbMC00XVxcXFxkfDI1WzAtNV0pKXsyfSg/OlxcXFwuKD86WzAtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSstKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykoPzpcXFxcLig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSstKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykqKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZl17Mix9KSkpfGxvY2FsaG9zdCkoPzo6XFxcXGR7Miw1fSk/KD86KC98XFxcXD98IylbXlxcXFxzXSopPyQnLFxuICAvLyAgICdpJyxcbiAgLy8gKSxcbiAgaGV4OiAvXiM/KFthLWYwLTldezZ9fFthLWYwLTldezN9KSQvaVxufTtcbnZhciB0eXBlcyA9IHtcbiAgaW50ZWdlcjogZnVuY3Rpb24gaW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlcy5udW1iZXIodmFsdWUpICYmIHBhcnNlSW50KHZhbHVlLCAxMCkgPT09IHZhbHVlO1xuICB9LFxuICBcImZsb2F0XCI6IGZ1bmN0aW9uIGZsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVzLm51bWJlcih2YWx1ZSkgJiYgIXR5cGVzLmludGVnZXIodmFsdWUpO1xuICB9LFxuICBhcnJheTogZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0sXG4gIHJlZ2V4cDogZnVuY3Rpb24gcmVnZXhwKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgZGF0ZTogZnVuY3Rpb24gZGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUuZ2V0VGltZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZ2V0TW9udGggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldFllYXIgPT09ICdmdW5jdGlvbicgJiYgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSk7XG4gIH0sXG4gIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICF0eXBlcy5hcnJheSh2YWx1ZSk7XG4gIH0sXG4gIG1ldGhvZDogZnVuY3Rpb24gbWV0aG9kKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSxcbiAgZW1haWw6IGZ1bmN0aW9uIGVtYWlsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoIDw9IDMyMCAmJiAhIXZhbHVlLm1hdGNoKHBhdHRlcm4kMi5lbWFpbCk7XG4gIH0sXG4gIHVybDogZnVuY3Rpb24gdXJsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoIDw9IDIwNDggJiYgISF2YWx1ZS5tYXRjaChnZXRVcmxSZWdleCgpKTtcbiAgfSxcbiAgaGV4OiBmdW5jdGlvbiBoZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhIXZhbHVlLm1hdGNoKHBhdHRlcm4kMi5oZXgpO1xuICB9XG59O1xuXG52YXIgdHlwZSQxID0gZnVuY3Rpb24gdHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpIHtcbiAgaWYgKHJ1bGUucmVxdWlyZWQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlcXVpcmVkJDEocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VzdG9tID0gWydpbnRlZ2VyJywgJ2Zsb2F0JywgJ2FycmF5JywgJ3JlZ2V4cCcsICdvYmplY3QnLCAnbWV0aG9kJywgJ2VtYWlsJywgJ251bWJlcicsICdkYXRlJywgJ3VybCcsICdoZXgnXTtcbiAgdmFyIHJ1bGVUeXBlID0gcnVsZS50eXBlO1xuXG4gIGlmIChjdXN0b20uaW5kZXhPZihydWxlVHlwZSkgPiAtMSkge1xuICAgIGlmICghdHlwZXNbcnVsZVR5cGVdKHZhbHVlKSkge1xuICAgICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMudHlwZXNbcnVsZVR5cGVdLCBydWxlLmZ1bGxGaWVsZCwgcnVsZS50eXBlKSk7XG4gICAgfSAvLyBzdHJhaWdodCB0eXBlb2YgY2hlY2tcblxuICB9IGVsc2UgaWYgKHJ1bGVUeXBlICYmIHR5cGVvZiB2YWx1ZSAhPT0gcnVsZS50eXBlKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMudHlwZXNbcnVsZVR5cGVdLCBydWxlLmZ1bGxGaWVsZCwgcnVsZS50eXBlKSk7XG4gIH1cbn07XG5cbnZhciByYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucykge1xuICB2YXIgbGVuID0gdHlwZW9mIHJ1bGUubGVuID09PSAnbnVtYmVyJztcbiAgdmFyIG1pbiA9IHR5cGVvZiBydWxlLm1pbiA9PT0gJ251bWJlcic7XG4gIHZhciBtYXggPSB0eXBlb2YgcnVsZS5tYXggPT09ICdudW1iZXInOyAvLyDmraPliJnljLnphY3noIHngrnojIPlm7Tku45VKzAxMDAwMOS4gOebtOWIsFUrMTBGRkZG55qE5paH5a2X77yI6KGl5YWF5bmz6Z2iU3VwcGxlbWVudGFyeSBQbGFuZe+8iVxuXG4gIHZhciBzcFJlZ2V4cCA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2c7XG4gIHZhciB2YWwgPSB2YWx1ZTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciBudW0gPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB2YXIgc3RyID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgdmFyIGFyciA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4gIGlmIChudW0pIHtcbiAgICBrZXkgPSAnbnVtYmVyJztcbiAgfSBlbHNlIGlmIChzdHIpIHtcbiAgICBrZXkgPSAnc3RyaW5nJztcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBrZXkgPSAnYXJyYXknO1xuICB9IC8vIGlmIHRoZSB2YWx1ZSBpcyBub3Qgb2YgYSBzdXBwb3J0ZWQgdHlwZSBmb3IgcmFuZ2UgdmFsaWRhdGlvblxuICAvLyB0aGUgdmFsaWRhdGlvbiBydWxlIHJ1bGUgc2hvdWxkIHVzZSB0aGVcbiAgLy8gdHlwZSBwcm9wZXJ0eSB0byBhbHNvIHRlc3QgZm9yIGEgcGFydGljdWxhciB0eXBlXG5cblxuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcnIpIHtcbiAgICB2YWwgPSB2YWx1ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAoc3RyKSB7XG4gICAgLy8g5aSE55CG56CB54K55aSn5LqOVSswMTAwMDDnmoTmloflrZdsZW5ndGjlsZ7mgKfkuI3lh4bnoa7nmoRidWfvvIzlpoJcIvCgrrfwoK638KCut1wiLmxlbmdodCAhPT0gM1xuICAgIHZhbCA9IHZhbHVlLnJlcGxhY2Uoc3BSZWdleHAsICdfJykubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGxlbikge1xuICAgIGlmICh2YWwgIT09IHJ1bGUubGVuKSB7XG4gICAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlc1trZXldLmxlbiwgcnVsZS5mdWxsRmllbGQsIHJ1bGUubGVuKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1pbiAmJiAhbWF4ICYmIHZhbCA8IHJ1bGUubWluKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNba2V5XS5taW4sIHJ1bGUuZnVsbEZpZWxkLCBydWxlLm1pbikpO1xuICB9IGVsc2UgaWYgKG1heCAmJiAhbWluICYmIHZhbCA+IHJ1bGUubWF4KSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNba2V5XS5tYXgsIHJ1bGUuZnVsbEZpZWxkLCBydWxlLm1heCkpO1xuICB9IGVsc2UgaWYgKG1pbiAmJiBtYXggJiYgKHZhbCA8IHJ1bGUubWluIHx8IHZhbCA+IHJ1bGUubWF4KSkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzW2tleV0ucmFuZ2UsIHJ1bGUuZnVsbEZpZWxkLCBydWxlLm1pbiwgcnVsZS5tYXgpKTtcbiAgfVxufTtcblxudmFyIEVOVU0kMSA9ICdlbnVtJztcblxudmFyIGVudW1lcmFibGUkMSA9IGZ1bmN0aW9uIGVudW1lcmFibGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKSB7XG4gIHJ1bGVbRU5VTSQxXSA9IEFycmF5LmlzQXJyYXkocnVsZVtFTlVNJDFdKSA/IHJ1bGVbRU5VTSQxXSA6IFtdO1xuXG4gIGlmIChydWxlW0VOVU0kMV0uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNbRU5VTSQxXSwgcnVsZS5mdWxsRmllbGQsIHJ1bGVbRU5VTSQxXS5qb2luKCcsICcpKSk7XG4gIH1cbn07XG5cbnZhciBwYXR0ZXJuJDEgPSBmdW5jdGlvbiBwYXR0ZXJuKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucykge1xuICBpZiAocnVsZS5wYXR0ZXJuKSB7XG4gICAgaWYgKHJ1bGUucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gaWYgYSBSZWdFeHAgaW5zdGFuY2UgaXMgcGFzc2VkLCByZXNldCBgbGFzdEluZGV4YCBpbiBjYXNlIGl0cyBgZ2xvYmFsYFxuICAgICAgLy8gZmxhZyBpcyBhY2NpZGVudGFsbHkgc2V0IHRvIGB0cnVlYCwgd2hpY2ggaW4gYSB2YWxpZGF0aW9uIHNjZW5hcmlvXG4gICAgICAvLyBpcyBub3QgbmVjZXNzYXJ5IGFuZCB0aGUgcmVzdWx0IG1pZ2h0IGJlIG1pc2xlYWRpbmdcbiAgICAgIHJ1bGUucGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXG4gICAgICBpZiAoIXJ1bGUucGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlcy5wYXR0ZXJuLm1pc21hdGNoLCBydWxlLmZ1bGxGaWVsZCwgdmFsdWUsIHJ1bGUucGF0dGVybikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGUucGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBfcGF0dGVybiA9IG5ldyBSZWdFeHAocnVsZS5wYXR0ZXJuKTtcblxuICAgICAgaWYgKCFfcGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlcy5wYXR0ZXJuLm1pc21hdGNoLCBydWxlLmZ1bGxGaWVsZCwgdmFsdWUsIHJ1bGUucGF0dGVybikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHJ1bGVzID0ge1xuICByZXF1aXJlZDogcmVxdWlyZWQkMSxcbiAgd2hpdGVzcGFjZTogd2hpdGVzcGFjZSxcbiAgdHlwZTogdHlwZSQxLFxuICByYW5nZTogcmFuZ2UsXG4gIFwiZW51bVwiOiBlbnVtZXJhYmxlJDEsXG4gIHBhdHRlcm46IHBhdHRlcm4kMVxufTtcblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUsICdzdHJpbmcnKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zLCAnc3RyaW5nJyk7XG5cbiAgICBpZiAoIWlzRW1wdHlWYWx1ZSh2YWx1ZSwgJ3N0cmluZycpKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICBydWxlcy5yYW5nZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucGF0dGVybihydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAocnVsZS53aGl0ZXNwYWNlID09PSB0cnVlKSB7XG4gICAgICAgIHJ1bGVzLndoaXRlc3BhY2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIG1ldGhvZCA9IGZ1bmN0aW9uIG1ldGhvZChydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIG51bWJlciA9IGZ1bmN0aW9uIG51bWJlcihydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBfYm9vbGVhbiA9IGZ1bmN0aW9uIF9ib29sZWFuKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgcmVnZXhwID0gZnVuY3Rpb24gcmVnZXhwKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWlzRW1wdHlWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIGludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucmFuZ2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIGZsb2F0Rm4gPSBmdW5jdGlvbiBmbG9hdEZuKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucmFuZ2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIGFycmF5ID0gZnVuY3Rpb24gYXJyYXkocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsICdhcnJheScpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3QocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBFTlVNID0gJ2VudW0nO1xuXG52YXIgZW51bWVyYWJsZSA9IGZ1bmN0aW9uIGVudW1lcmFibGUocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBydWxlc1tFTlVNXShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgcGF0dGVybiA9IGZ1bmN0aW9uIHBhdHRlcm4ocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlLCAnc3RyaW5nJykgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWlzRW1wdHlWYWx1ZSh2YWx1ZSwgJ3N0cmluZycpKSB7XG4gICAgICBydWxlcy5wYXR0ZXJuKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBkYXRlID0gZnVuY3Rpb24gZGF0ZShydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICAvLyBjb25zb2xlLmxvZygnaW50ZWdlciBydWxlIGNhbGxlZCAlaicsIHJ1bGUpO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpOyAvLyBjb25zb2xlLmxvZygndmFsaWRhdGUgb24gJXMgdmFsdWUnLCB2YWx1ZSk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSwgJ2RhdGUnKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlLCAnZGF0ZScpKSB7XG4gICAgICB2YXIgZGF0ZU9iamVjdDtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBkYXRlT2JqZWN0ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlT2JqZWN0ID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBydWxlcy50eXBlKHJ1bGUsIGRhdGVPYmplY3QsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGRhdGVPYmplY3QpIHtcbiAgICAgICAgcnVsZXMucmFuZ2UocnVsZSwgZGF0ZU9iamVjdC5nZXRUaW1lKCksIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIHJlcXVpcmVkID0gZnVuY3Rpb24gcmVxdWlyZWQocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdHlwZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gJ2FycmF5JyA6IHR5cGVvZiB2YWx1ZTtcbiAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zLCB0eXBlKTtcbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciB0eXBlID0gZnVuY3Rpb24gdHlwZShydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgcnVsZVR5cGUgPSBydWxlLnR5cGU7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSwgcnVsZVR5cGUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsIHJ1bGVUeXBlKTtcblxuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlLCBydWxlVHlwZSkpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIGFueSA9IGZ1bmN0aW9uIGFueShydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciB2YWxpZGF0b3JzID0ge1xuICBzdHJpbmc6IHN0cmluZyxcbiAgbWV0aG9kOiBtZXRob2QsXG4gIG51bWJlcjogbnVtYmVyLFxuICBcImJvb2xlYW5cIjogX2Jvb2xlYW4sXG4gIHJlZ2V4cDogcmVnZXhwLFxuICBpbnRlZ2VyOiBpbnRlZ2VyLFxuICBcImZsb2F0XCI6IGZsb2F0Rm4sXG4gIGFycmF5OiBhcnJheSxcbiAgb2JqZWN0OiBvYmplY3QsXG4gIFwiZW51bVwiOiBlbnVtZXJhYmxlLFxuICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICBkYXRlOiBkYXRlLFxuICB1cmw6IHR5cGUsXG4gIGhleDogdHlwZSxcbiAgZW1haWw6IHR5cGUsXG4gIHJlcXVpcmVkOiByZXF1aXJlZCxcbiAgYW55OiBhbnlcbn07XG5cbmZ1bmN0aW9uIG5ld01lc3NhZ2VzKCkge1xuICByZXR1cm4ge1xuICAgIFwiZGVmYXVsdFwiOiAnVmFsaWRhdGlvbiBlcnJvciBvbiBmaWVsZCAlcycsXG4gICAgcmVxdWlyZWQ6ICclcyBpcyByZXF1aXJlZCcsXG4gICAgXCJlbnVtXCI6ICclcyBtdXN0IGJlIG9uZSBvZiAlcycsXG4gICAgd2hpdGVzcGFjZTogJyVzIGNhbm5vdCBiZSBlbXB0eScsXG4gICAgZGF0ZToge1xuICAgICAgZm9ybWF0OiAnJXMgZGF0ZSAlcyBpcyBpbnZhbGlkIGZvciBmb3JtYXQgJXMnLFxuICAgICAgcGFyc2U6ICclcyBkYXRlIGNvdWxkIG5vdCBiZSBwYXJzZWQsICVzIGlzIGludmFsaWQgJyxcbiAgICAgIGludmFsaWQ6ICclcyBkYXRlICVzIGlzIGludmFsaWQnXG4gICAgfSxcbiAgICB0eXBlczoge1xuICAgICAgc3RyaW5nOiAnJXMgaXMgbm90IGEgJXMnLFxuICAgICAgbWV0aG9kOiAnJXMgaXMgbm90IGEgJXMgKGZ1bmN0aW9uKScsXG4gICAgICBhcnJheTogJyVzIGlzIG5vdCBhbiAlcycsXG4gICAgICBvYmplY3Q6ICclcyBpcyBub3QgYW4gJXMnLFxuICAgICAgbnVtYmVyOiAnJXMgaXMgbm90IGEgJXMnLFxuICAgICAgZGF0ZTogJyVzIGlzIG5vdCBhICVzJyxcbiAgICAgIFwiYm9vbGVhblwiOiAnJXMgaXMgbm90IGEgJXMnLFxuICAgICAgaW50ZWdlcjogJyVzIGlzIG5vdCBhbiAlcycsXG4gICAgICBcImZsb2F0XCI6ICclcyBpcyBub3QgYSAlcycsXG4gICAgICByZWdleHA6ICclcyBpcyBub3QgYSB2YWxpZCAlcycsXG4gICAgICBlbWFpbDogJyVzIGlzIG5vdCBhIHZhbGlkICVzJyxcbiAgICAgIHVybDogJyVzIGlzIG5vdCBhIHZhbGlkICVzJyxcbiAgICAgIGhleDogJyVzIGlzIG5vdCBhIHZhbGlkICVzJ1xuICAgIH0sXG4gICAgc3RyaW5nOiB7XG4gICAgICBsZW46ICclcyBtdXN0IGJlIGV4YWN0bHkgJXMgY2hhcmFjdGVycycsXG4gICAgICBtaW46ICclcyBtdXN0IGJlIGF0IGxlYXN0ICVzIGNoYXJhY3RlcnMnLFxuICAgICAgbWF4OiAnJXMgY2Fubm90IGJlIGxvbmdlciB0aGFuICVzIGNoYXJhY3RlcnMnLFxuICAgICAgcmFuZ2U6ICclcyBtdXN0IGJlIGJldHdlZW4gJXMgYW5kICVzIGNoYXJhY3RlcnMnXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIGxlbjogJyVzIG11c3QgZXF1YWwgJXMnLFxuICAgICAgbWluOiAnJXMgY2Fubm90IGJlIGxlc3MgdGhhbiAlcycsXG4gICAgICBtYXg6ICclcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICVzJyxcbiAgICAgIHJhbmdlOiAnJXMgbXVzdCBiZSBiZXR3ZWVuICVzIGFuZCAlcydcbiAgICB9LFxuICAgIGFycmF5OiB7XG4gICAgICBsZW46ICclcyBtdXN0IGJlIGV4YWN0bHkgJXMgaW4gbGVuZ3RoJyxcbiAgICAgIG1pbjogJyVzIGNhbm5vdCBiZSBsZXNzIHRoYW4gJXMgaW4gbGVuZ3RoJyxcbiAgICAgIG1heDogJyVzIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJXMgaW4gbGVuZ3RoJyxcbiAgICAgIHJhbmdlOiAnJXMgbXVzdCBiZSBiZXR3ZWVuICVzIGFuZCAlcyBpbiBsZW5ndGgnXG4gICAgfSxcbiAgICBwYXR0ZXJuOiB7XG4gICAgICBtaXNtYXRjaDogJyVzIHZhbHVlICVzIGRvZXMgbm90IG1hdGNoIHBhdHRlcm4gJXMnXG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB2YXIgY2xvbmVkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzKSk7XG4gICAgICBjbG9uZWQuY2xvbmUgPSB0aGlzLmNsb25lO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIH07XG59XG52YXIgbWVzc2FnZXMgPSBuZXdNZXNzYWdlcygpO1xuXG4vKipcbiAqICBFbmNhcHN1bGF0ZXMgYSB2YWxpZGF0aW9uIHNjaGVtYS5cbiAqXG4gKiAgQHBhcmFtIGRlc2NyaXB0b3IgQW4gb2JqZWN0IGRlY2xhcmluZyB2YWxpZGF0aW9uIHJ1bGVzXG4gKiAgZm9yIHRoaXMgc2NoZW1hLlxuICovXG5cbnZhciBTY2hlbWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IFN0YXRpYyA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PSBJbnN0YW5jZSA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gU2NoZW1hKGRlc2NyaXB0b3IpIHtcbiAgICB0aGlzLnJ1bGVzID0gbnVsbDtcbiAgICB0aGlzLl9tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgIHRoaXMuZGVmaW5lKGRlc2NyaXB0b3IpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjaGVtYS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShydWxlcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXJ1bGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25maWd1cmUgYSBzY2hlbWEgd2l0aCBubyBydWxlcycpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcnVsZXMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHJ1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgaXRlbSA9IHJ1bGVzW25hbWVdO1xuICAgICAgX3RoaXMucnVsZXNbbmFtZV0gPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubWVzc2FnZXMgPSBmdW5jdGlvbiBtZXNzYWdlcyhfbWVzc2FnZXMpIHtcbiAgICBpZiAoX21lc3NhZ2VzKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlcyA9IGRlZXBNZXJnZShuZXdNZXNzYWdlcygpLCBfbWVzc2FnZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlcztcbiAgfTtcblxuICBfcHJvdG8udmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShzb3VyY2VfLCBvLCBvYykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKG8gPT09IHZvaWQgMCkge1xuICAgICAgbyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvYyA9PT0gdm9pZCAwKSB7XG4gICAgICBvYyA9IGZ1bmN0aW9uIG9jKCkge307XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZV87XG4gICAgdmFyIG9wdGlvbnMgPSBvO1xuICAgIHZhciBjYWxsYmFjayA9IG9jO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJ1bGVzIHx8IE9iamVjdC5rZXlzKHRoaXMucnVsZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZShyZXN1bHRzKSB7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgZmllbGRzID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIGFkZChlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgdmFyIF9lcnJvcnM7XG5cbiAgICAgICAgICBlcnJvcnMgPSAoX2Vycm9ycyA9IGVycm9ycykuY29uY2F0LmFwcGx5KF9lcnJvcnMsIGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhZGQocmVzdWx0c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGRzID0gY29udmVydEZpZWxkc0Vycm9yKGVycm9ycyk7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycywgZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgdmFyIG1lc3NhZ2VzJDEgPSB0aGlzLm1lc3NhZ2VzKCk7XG5cbiAgICAgIGlmIChtZXNzYWdlcyQxID09PSBtZXNzYWdlcykge1xuICAgICAgICBtZXNzYWdlcyQxID0gbmV3TWVzc2FnZXMoKTtcbiAgICAgIH1cblxuICAgICAgZGVlcE1lcmdlKG1lc3NhZ2VzJDEsIG9wdGlvbnMubWVzc2FnZXMpO1xuICAgICAgb3B0aW9ucy5tZXNzYWdlcyA9IG1lc3NhZ2VzJDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMubWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzKCk7XG4gICAgfVxuXG4gICAgdmFyIHNlcmllcyA9IHt9O1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzIHx8IE9iamVjdC5rZXlzKHRoaXMucnVsZXMpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoeikge1xuICAgICAgdmFyIGFyciA9IF90aGlzMi5ydWxlc1t6XTtcbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVt6XTtcbiAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciBydWxlID0gcjtcblxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZSA9PT0gc291cmNlXykge1xuICAgICAgICAgICAgc291cmNlID0gX2V4dGVuZHMoe30sIHNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSBzb3VyY2Vbel0gPSBydWxlLnRyYW5zZm9ybSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBydWxlID0ge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBydWxlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydWxlID0gX2V4dGVuZHMoe30sIHJ1bGUpO1xuICAgICAgICB9IC8vIEZpbGwgdmFsaWRhdG9yLiBTa2lwIGlmIG5vdGhpbmcgbmVlZCB0byB2YWxpZGF0ZVxuXG5cbiAgICAgICAgcnVsZS52YWxpZGF0b3IgPSBfdGhpczIuZ2V0VmFsaWRhdGlvbk1ldGhvZChydWxlKTtcblxuICAgICAgICBpZiAoIXJ1bGUudmFsaWRhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcnVsZS5maWVsZCA9IHo7XG4gICAgICAgIHJ1bGUuZnVsbEZpZWxkID0gcnVsZS5mdWxsRmllbGQgfHwgejtcbiAgICAgICAgcnVsZS50eXBlID0gX3RoaXMyLmdldFR5cGUocnVsZSk7XG4gICAgICAgIHNlcmllc1t6XSA9IHNlcmllc1t6XSB8fCBbXTtcbiAgICAgICAgc2VyaWVzW3pdLnB1c2goe1xuICAgICAgICAgIHJ1bGU6IHJ1bGUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGZpZWxkOiB6XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGVycm9yRmllbGRzID0ge307XG4gICAgcmV0dXJuIGFzeW5jTWFwKHNlcmllcywgb3B0aW9ucywgZnVuY3Rpb24gKGRhdGEsIGRvSXQpIHtcbiAgICAgIHZhciBydWxlID0gZGF0YS5ydWxlO1xuICAgICAgdmFyIGRlZXAgPSAocnVsZS50eXBlID09PSAnb2JqZWN0JyB8fCBydWxlLnR5cGUgPT09ICdhcnJheScpICYmICh0eXBlb2YgcnVsZS5maWVsZHMgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBydWxlLmRlZmF1bHRGaWVsZCA9PT0gJ29iamVjdCcpO1xuICAgICAgZGVlcCA9IGRlZXAgJiYgKHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgZGF0YS52YWx1ZSk7XG4gICAgICBydWxlLmZpZWxkID0gZGF0YS5maWVsZDtcblxuICAgICAgZnVuY3Rpb24gYWRkRnVsbEZpZWxkKGtleSwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc2NoZW1hLCB7XG4gICAgICAgICAgZnVsbEZpZWxkOiBydWxlLmZ1bGxGaWVsZCArIFwiLlwiICsga2V5LFxuICAgICAgICAgIGZ1bGxGaWVsZHM6IHJ1bGUuZnVsbEZpZWxkcyA/IFtdLmNvbmNhdChydWxlLmZ1bGxGaWVsZHMsIFtrZXldKSA6IFtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYihlKSB7XG4gICAgICAgIGlmIChlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXJyb3JMaXN0ID0gQXJyYXkuaXNBcnJheShlKSA/IGUgOiBbZV07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnN1cHByZXNzV2FybmluZyAmJiBlcnJvckxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgU2NoZW1hLndhcm5pbmcoJ2FzeW5jLXZhbGlkYXRvcjonLCBlcnJvckxpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yTGlzdC5sZW5ndGggJiYgcnVsZS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlcnJvckxpc3QgPSBbXS5jb25jYXQocnVsZS5tZXNzYWdlKTtcbiAgICAgICAgfSAvLyBGaWxsIGVycm9yIGluZm9cblxuXG4gICAgICAgIHZhciBmaWxsZWRFcnJvcnMgPSBlcnJvckxpc3QubWFwKGNvbXBsZW1lbnRFcnJvcihydWxlLCBzb3VyY2UpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5maXJzdCAmJiBmaWxsZWRFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgZXJyb3JGaWVsZHNbcnVsZS5maWVsZF0gPSAxO1xuICAgICAgICAgIHJldHVybiBkb0l0KGZpbGxlZEVycm9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlZXApIHtcbiAgICAgICAgICBkb0l0KGZpbGxlZEVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgcnVsZSBpcyByZXF1aXJlZCBidXQgdGhlIHRhcmdldCBvYmplY3RcbiAgICAgICAgICAvLyBkb2VzIG5vdCBleGlzdCBmYWlsIGF0IHRoZSBydWxlIGxldmVsIGFuZCBkb24ndFxuICAgICAgICAgIC8vIGdvIGRlZXBlclxuICAgICAgICAgIGlmIChydWxlLnJlcXVpcmVkICYmICFkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocnVsZS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmlsbGVkRXJyb3JzID0gW10uY29uY2F0KHJ1bGUubWVzc2FnZSkubWFwKGNvbXBsZW1lbnRFcnJvcihydWxlLCBzb3VyY2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgICAgICBmaWxsZWRFcnJvcnMgPSBbb3B0aW9ucy5lcnJvcihydWxlLCBmb3JtYXQob3B0aW9ucy5tZXNzYWdlcy5yZXF1aXJlZCwgcnVsZS5maWVsZCkpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRvSXQoZmlsbGVkRXJyb3JzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZmllbGRzU2NoZW1hID0ge307XG5cbiAgICAgICAgICBpZiAocnVsZS5kZWZhdWx0RmllbGQpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEudmFsdWUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIGZpZWxkc1NjaGVtYVtrZXldID0gcnVsZS5kZWZhdWx0RmllbGQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWVsZHNTY2hlbWEgPSBfZXh0ZW5kcyh7fSwgZmllbGRzU2NoZW1hLCBkYXRhLnJ1bGUuZmllbGRzKTtcbiAgICAgICAgICB2YXIgcGFyZWRGaWVsZHNTY2hlbWEgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhmaWVsZHNTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgZmllbGRTY2hlbWEgPSBmaWVsZHNTY2hlbWFbZmllbGRdO1xuICAgICAgICAgICAgdmFyIGZpZWxkU2NoZW1hTGlzdCA9IEFycmF5LmlzQXJyYXkoZmllbGRTY2hlbWEpID8gZmllbGRTY2hlbWEgOiBbZmllbGRTY2hlbWFdO1xuICAgICAgICAgICAgcGFyZWRGaWVsZHNTY2hlbWFbZmllbGRdID0gZmllbGRTY2hlbWFMaXN0Lm1hcChhZGRGdWxsRmllbGQuYmluZChudWxsLCBmaWVsZCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzY2hlbWEgPSBuZXcgU2NoZW1hKHBhcmVkRmllbGRzU2NoZW1hKTtcbiAgICAgICAgICBzY2hlbWEubWVzc2FnZXMob3B0aW9ucy5tZXNzYWdlcyk7XG5cbiAgICAgICAgICBpZiAoZGF0YS5ydWxlLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRhdGEucnVsZS5vcHRpb25zLm1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgICAgICAgIGRhdGEucnVsZS5vcHRpb25zLmVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlbWEudmFsaWRhdGUoZGF0YS52YWx1ZSwgZGF0YS5ydWxlLm9wdGlvbnMgfHwgb3B0aW9ucywgZnVuY3Rpb24gKGVycnMpIHtcbiAgICAgICAgICAgIHZhciBmaW5hbEVycm9ycyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoZmlsbGVkRXJyb3JzICYmIGZpbGxlZEVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZmluYWxFcnJvcnMucHVzaC5hcHBseShmaW5hbEVycm9ycywgZmlsbGVkRXJyb3JzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVycnMgJiYgZXJycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZmluYWxFcnJvcnMucHVzaC5hcHBseShmaW5hbEVycm9ycywgZXJycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvSXQoZmluYWxFcnJvcnMubGVuZ3RoID8gZmluYWxFcnJvcnMgOiBudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzO1xuXG4gICAgICBpZiAocnVsZS5hc3luY1ZhbGlkYXRvcikge1xuICAgICAgICByZXMgPSBydWxlLmFzeW5jVmFsaWRhdG9yKHJ1bGUsIGRhdGEudmFsdWUsIGNiLCBkYXRhLnNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHJ1bGUudmFsaWRhdG9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gcnVsZS52YWxpZGF0b3IocnVsZSwgZGF0YS52YWx1ZSwgY2IsIGRhdGEuc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yID09IG51bGwgPyB2b2lkIDAgOiBjb25zb2xlLmVycm9yKGVycm9yKTsgLy8gcmV0aHJvdyB0byByZXBvcnQgZXJyb3JcblxuICAgICAgICAgIGlmICghb3B0aW9ucy5zdXBwcmVzc1ZhbGlkYXRvckVycm9yKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXMgPT09IHRydWUpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjYih0eXBlb2YgcnVsZS5tZXNzYWdlID09PSAnZnVuY3Rpb24nID8gcnVsZS5tZXNzYWdlKHJ1bGUuZnVsbEZpZWxkIHx8IHJ1bGUuZmllbGQpIDogcnVsZS5tZXNzYWdlIHx8IChydWxlLmZ1bGxGaWVsZCB8fCBydWxlLmZpZWxkKSArIFwiIGZhaWxzXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgY2IocmVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGNiKHJlcy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzICYmIHJlcy50aGVuKSB7XG4gICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICBjb21wbGV0ZShyZXN1bHRzKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIF9wcm90by5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZShydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSA9PT0gdW5kZWZpbmVkICYmIHJ1bGUucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcnVsZS50eXBlID0gJ3BhdHRlcm4nO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcnVsZS52YWxpZGF0b3IgIT09ICdmdW5jdGlvbicgJiYgcnVsZS50eXBlICYmICF2YWxpZGF0b3JzLmhhc093blByb3BlcnR5KHJ1bGUudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ1Vua25vd24gcnVsZSB0eXBlICVzJywgcnVsZS50eXBlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGUudHlwZSB8fCAnc3RyaW5nJztcbiAgfTtcblxuICBfcHJvdG8uZ2V0VmFsaWRhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIGdldFZhbGlkYXRpb25NZXRob2QocnVsZSkge1xuICAgIGlmICh0eXBlb2YgcnVsZS52YWxpZGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBydWxlLnZhbGlkYXRvcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJ1bGUpO1xuICAgIHZhciBtZXNzYWdlSW5kZXggPSBrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKTtcblxuICAgIGlmIChtZXNzYWdlSW5kZXggIT09IC0xKSB7XG4gICAgICBrZXlzLnNwbGljZShtZXNzYWdlSW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAncmVxdWlyZWQnKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdG9ycy5yZXF1aXJlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yc1t0aGlzLmdldFR5cGUocnVsZSldIHx8IHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gU2NoZW1hO1xufSgpO1xuXG5TY2hlbWEucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcih0eXBlLCB2YWxpZGF0b3IpIHtcbiAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhIHZhbGlkYXRvciBieSB0eXBlLCB2YWxpZGF0b3IgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhbGlkYXRvcnNbdHlwZV0gPSB2YWxpZGF0b3I7XG59O1xuXG5TY2hlbWEud2FybmluZyA9IHdhcm5pbmc7XG5TY2hlbWEubWVzc2FnZXMgPSBtZXNzYWdlcztcblNjaGVtYS52YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcblxuZXhwb3J0IHsgU2NoZW1hIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfc2V0UHJvdG90eXBlT2YiLCJfZ2V0UHJvdG90eXBlT2YiLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInAiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiZSIsIl9jb25zdHJ1Y3QiLCJQYXJlbnQiLCJhcmdzIiwiQ2xhc3MiLCJhIiwicHVzaCIsIkNvbnN0cnVjdG9yIiwiRnVuY3Rpb24iLCJpbnN0YW5jZSIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiZm4iLCJ0b1N0cmluZyIsImluZGV4T2YiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiX2NhY2hlIiwiTWFwIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiaGFzIiwiZ2V0Iiwic2V0IiwiV3JhcHBlciIsInZhbHVlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZm9ybWF0UmVnRXhwIiwid2FybmluZyIsInByb2Nlc3MiLCJlbnYiLCJkb2N1bWVudCIsInR5cGUiLCJlcnJvcnMiLCJjb25zb2xlIiwid2FybiIsIkFTWU5DX1ZBTElEQVRPUl9OT19XQVJOSU5HIiwiZXZlcnkiLCJjb252ZXJ0RmllbGRzRXJyb3IiLCJmaWVsZHMiLCJmb3JFYWNoIiwiZXJyb3IiLCJmaWVsZCIsImZvcm1hdCIsInRlbXBsYXRlIiwiX2xlbiIsIkFycmF5IiwiX2tleSIsImxlbiIsInN0ciIsInJlcGxhY2UiLCJ4IiwiU3RyaW5nIiwiTnVtYmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsIl8iLCJpc05hdGl2ZVN0cmluZ1R5cGUiLCJpc0VtcHR5VmFsdWUiLCJpc0FycmF5IiwiYXN5bmNQYXJhbGxlbEFycmF5IiwiYXJyIiwiZnVuYyIsImNhbGxiYWNrIiwicmVzdWx0cyIsInRvdGFsIiwiYXJyTGVuZ3RoIiwiY291bnQiLCJhc3luY1NlcmlhbEFycmF5IiwiaW5kZXgiLCJuZXh0Iiwib3JpZ2luYWwiLCJmbGF0dGVuT2JqQXJyIiwib2JqQXJyIiwicmV0Iiwia2V5cyIsImsiLCJBc3luY1ZhbGlkYXRpb25FcnJvciIsIl9FcnJvciIsIl90aGlzIiwiRXJyb3IiLCJhc3luY01hcCIsIm9wdGlvbiIsImZpcnN0IiwiX3BlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZsYXR0ZW5BcnIiLCJmaXJzdEZpZWxkcyIsIm9iakFycktleXMiLCJvYmpBcnJMZW5ndGgiLCJwZW5kaW5nIiwiaXNFcnJvck9iaiIsIm9iaiIsIm1lc3NhZ2UiLCJnZXRWYWx1ZSIsInBhdGgiLCJ2IiwiY29tcGxlbWVudEVycm9yIiwicnVsZSIsIm9lIiwiZmllbGRWYWx1ZSIsImZ1bGxGaWVsZHMiLCJmdWxsRmllbGQiLCJkZWVwTWVyZ2UiLCJzIiwicmVxdWlyZWQkMSIsInJlcXVpcmVkIiwib3B0aW9ucyIsIm1lc3NhZ2VzIiwid2hpdGVzcGFjZSIsInRlc3QiLCJ1cmxSZWciLCJnZXRVcmxSZWdleCIsIndvcmQiLCJiIiwiaW5jbHVkZUJvdW5kYXJpZXMiLCJ2NCIsInY2c2VnIiwidjYiLCJ0cmltIiwidjQ2RXhhY3QiLCJSZWdFeHAiLCJ2NGV4YWN0IiwidjZleGFjdCIsImlwIiwiZXhhY3QiLCJwcm90b2NvbCIsImF1dGgiLCJpcHY0IiwiaXB2NiIsImhvc3QiLCJkb21haW4iLCJ0bGQiLCJwb3J0IiwicmVnZXgiLCJwYXR0ZXJuJDIiLCJlbWFpbCIsImhleCIsInR5cGVzIiwiaW50ZWdlciIsIm51bWJlciIsInBhcnNlSW50IiwiZmxvYXQiLCJhcnJheSIsInJlZ2V4cCIsImRhdGUiLCJnZXRUaW1lIiwiZ2V0TW9udGgiLCJnZXRZZWFyIiwiaXNOYU4iLCJvYmplY3QiLCJtZXRob2QiLCJtYXRjaCIsInVybCIsInR5cGUkMSIsImN1c3RvbSIsInJ1bGVUeXBlIiwicmFuZ2UiLCJtaW4iLCJtYXgiLCJzcFJlZ2V4cCIsInZhbCIsIm51bSIsIkVOVU0kMSIsImVudW1lcmFibGUkMSIsImpvaW4iLCJwYXR0ZXJuJDEiLCJwYXR0ZXJuIiwibGFzdEluZGV4IiwibWlzbWF0Y2giLCJfcGF0dGVybiIsInJ1bGVzIiwic3RyaW5nIiwidmFsaWRhdGUiLCJfYm9vbGVhbiIsImZsb2F0Rm4iLCJFTlVNIiwiZGF0ZU9iamVjdCIsIkRhdGUiLCJhbnkiLCJ2YWxpZGF0b3JzIiwibmV3TWVzc2FnZXMiLCJwYXJzZSIsImludmFsaWQiLCJjbG9uZSIsImNsb25lZCIsIlNjaGVtYSIsImRlc2NyaXB0b3IiLCJfbWVzc2FnZXMiLCJkZWZpbmUiLCJfcHJvdG8iLCJuYW1lIiwiaXRlbSIsInNvdXJjZV8iLCJvYyIsIl90aGlzMiIsImNvbXBsZXRlIiwiYWRkIiwiX2Vycm9ycyIsImNvbmNhdCIsIm1lc3NhZ2VzJDEiLCJzZXJpZXMiLCJ6IiwiciIsInRyYW5zZm9ybSIsInZhbGlkYXRvciIsImdldFZhbGlkYXRpb25NZXRob2QiLCJnZXRUeXBlIiwiZXJyb3JGaWVsZHMiLCJkYXRhIiwiZG9JdCIsImRlZXAiLCJkZWZhdWx0RmllbGQiLCJhZGRGdWxsRmllbGQiLCJzY2hlbWEiLCJjYiIsImVycm9yTGlzdCIsInN1cHByZXNzV2FybmluZyIsImZpbGxlZEVycm9ycyIsIm1hcCIsImZpZWxkc1NjaGVtYSIsInBhcmVkRmllbGRzU2NoZW1hIiwiZmllbGRTY2hlbWEiLCJmaWVsZFNjaGVtYUxpc3QiLCJlcnJzIiwiZmluYWxFcnJvcnMiLCJyZXMiLCJhc3luY1ZhbGlkYXRvciIsInN1cHByZXNzVmFsaWRhdG9yRXJyb3IiLCJzZXRUaW1lb3V0IiwidGhlbiIsIm1lc3NhZ2VJbmRleCIsInNwbGljZSIsInJlZ2lzdGVyIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/async-validator/dist-web/index.js\n");

/***/ })

};
;